#!/usr/bin/python
# -*- coding: utf-8 -*-

import serial
import sys
import time
import datetime
import numpy as np
import pyqtgraph as pg

from pyqtgraph.Qt import QtCore, QtGui
from PyQt5.QtWidgets import QMessageBox
from PyQt5.QtGui import *
from serial.tools import list_ports
from Tkinter import Tk
from tkFileDialog import askopenfilename

from date_axis_custom import DateAxis
from settings import Settings
from win_capture_settings import Ui_CaptureSettingsWindow
from win_display_settings import Ui_DisplaySettingsWindow
# config files
capture_file = "config/capture.config"
display_file = "config/display.config"

# config tiva
t_start = 0
t_end = 3.3
ad = 12
const_board = (t_end - t_start) / (2 ** ad)

# config serial
ser = serial.Serial()
ser.baudrate = 115200
ser.timeout = 1

# class main
class Main(QtGui.QMainWindow):
    def __init__(self):
        QtGui.QMainWindow.__init__(self)

    def showCaptureSettings(self):
        self.ui_caps = Ui_CaptureSettingsWindow()
        self.ui_caps.setupUi(self)
        self.settings_data = Settings(None).load()
        # set capture data
        self.ui_caps.input_sampleR.setText(str(self.settings_data['sampleRate']))
        self.ui_caps.input_ch.setText(str(self.settings_data['channelsPerBoard']))
        self.ui_caps.input_numofboards.setText(str(self.settings_data['nBoards']))
        self.ui_caps.input_bits.setText(str(self.settings_data['bitsPerSample']))
        # init actions
        self.ui_caps.button_save.clicked.connect(self.storeCaptureSettings)
        self.ui_caps.button_cancel.clicked.connect(window.close)
        # self.stopTimer()
        window.show()

    # show display settings
    def showDisplaySettings(self):

        self.ui_display = Ui_DisplaySettingsWindow()
        self.ui_display.setupUi(self)
        self.settings_data = Settings(None).load()

        # set data
        self.ui_display.input_swipe.setText(str(self.settings_data['swipeSamples']))
        self.ui_display.input_zero.setText(str(self.settings_data['zero']))
        self.ui_display.input_vtick.setText(str(self.settings_data['vertTick']))
        self.ui_display.input_htick.setText(str(self.settings_data['horizTick']))
        self.ui_display.input_ampS.setText(str(self.settings_data['vMin']))
        self.ui_display.input_ampE.setText(str(self.settings_data['vMax']))
        # init actions
        self.ui_display.button_save.clicked.connect(self.storeDisplaySettings)
        self.ui_display.button_cancel.clicked.connect(window.close)
        # self.stopTimer()
        window.show()

    # store display settings
    def storeDisplaySettings(self):
        try:
            self.settings_data['swipeSamples'] = int(self.ui_display.input_swipe.text())
            check = 1 / self.swipe
        except:
            self.settings_data['swipeSamples'] = 1000
            print("ERROR swipe!")
        try:
            self.settings_data['zero'] = float(self.ui_display.input_zero.text())
        except:
            self.settings_data['zero'] = 0.0
            print("ERROR zero!")
        try:
            self.settings_data['vertTick'] = float(self.ui_display.input_vtick.text())
            check = 1 / self.vtick
        except:
            self.settings_data['vertTick'] = 1.0
            print("ERROR vtick!")
        try:
            self.settings_data['horizTick'] = float(self.ui_display.input_htick.text())
            check = 1 / self.htick
        except:
            self.settings_data['horizTick'] = 100.0
            print("ERROR htick!")
        try:
            self.settings_data['vMin'] = float(self.ui_display.input_ampS.text())
        except:
            self.settings_data['vMin'] = -2.0
            print("ERROR ampS!")
        try:
            self.settings_data['vMax'] = float(self.ui_display.input_ampE.text())
        except:
            self.settings_data['vMax'] = 2.0
            print("ERROR ampE!")

        self.settings_file.write("## File generated by leap_cap software \n"+
                                "## Available from github.com/ddantas/leap_cap \n"+
                                "## Timestamp: "+datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')+" \n"+
                                "##\n"+
                                "## EMG capture settings \n"+
                                "##\n")
        self.settings_file.writelines([
                                "# sampleRate: "+ str(self.settings_data['sampleRate']) + "\n", 
                                "# channelsPerBoard: " + str(self.settings_data['channelsPerBoard']) + "\n", 
                                "# nBoards: " + str(self.settings_data['nBoards']) + "\n", 
                                "# bitsPerSample: " + str(self.settings_data['bitsPerSample']) + "\n"
                            ])
        self.settings_file.write("##\n## EMG display settings\n##\n")
        self.settings_file.writelines([
                                "# swipeSamples: "+ str(self.settings_data['swipeSamples']) + "\n", 
                                "# zero: " + str(self.settings_data['zero']) + "\n", 
                                "# vertTick: " + str(self.settings_data['vertTick']) + "\n", 
                                "# horizTick: " + str(self.settings_data['horizTick']) + "\n", 
                                "# vMin: " + str(self.settings_data['vMin']) + "\n", 
                                "# vMax: " + str(self.settings_data['vMax'])
                            ])
        # self.clearGraph()
        # window.close()

    # store capture settings
    def storeCaptureSettings(self):
        try:
            self.settings_data['sampleRate'] = int(self.ui_caps.input_sampleR.text())
        except:
            print("ERROR sample rate!")

        self.settings_file.write("## File generated by leap_cap software \n"+
                                "## Available from github.com/ddantas/leap_cap \n"+
                                "## Timestamp: "+datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')+" \n"+
                                "##\n"+
                                "## EMG capture settings \n"+
                                "##\n")
        self.settings_file.writelines([
                                "# sampleRate: "+ str(self.settings_data['sampleRate']) + "\n", 
                                "# channelsPerBoard: " + str(self.settings_data['channelsPerBoard']) + "\n", 
                                "# nBoards: " + str(self.settings_data['nBoards']) + "\n", 
                                "# bitsPerSample: " + str(self.settings_data['bitsPerSample']) + "\n"
                            ])
        self.settings_file.write("##\n## EMG display settings\n##\n")
        self.settings_file.writelines([
                                "# swipeSamples: "+ str(self.settings_data['swipeSamples']) + "\n", 
                                "# zero: " + str(self.settings_data['zero']) + "\n", 
                                "# vertTick: " + str(self.settings_data['vertTick']) + "\n", 
                                "# horizTick: " + str(self.settings_data['horizTick']) + "\n", 
                                "# vMin: " + str(self.settings_data['vMin']) + "\n", 
                                "# vMax: " + str(self.settings_data['vMax'])
                            ])
        # self.clearGraph()
        window.close()

    # show message
    def showMessage(self, title, body):
        QMessageBox.about(self, title, body)
 
    # show input file
    def inputFile(self):
        self.timer.stop()
        Tk().withdraw() # we don't want a full GUI, so keep the root window from appearing
        self.file = askopenfilename() # show an "Open" dialog box and return the path to the selected file
    
    # store header log emg
    def writeHeader(self):
        output = open(self.log_file, "a")
        output.write("## File generated by myo_cap software\n"+
                    "## Available from github.com/ddantas/myo_cap\n"+
                    "## Timestamp: 2018-05-23_20-57-32\n"+
                    "##\n"+
                    "## EMG capture settings"+
                    "##\n"+
                    "# sampleRate: 2000\n"+
                    "# channelsPerBoard: 4\n"+
                    "# nBoards: 1\n"+
                    "# bitsPerSample: 12\n"+
                    "##\n"+
                    "## Data\n"+
                    "## t; ch0; ch1; ch2; ch3\n")
        output.close()
        window.close()

    # store data log emg
    def writeData(self):
        output = open(self.log_file, "a")
        for j in range(self.swipe):
            for i in range(self.len_ch):
                if (i < self.len_ch - 1):
                    output.write(str(self.data[i][j] - (self.zero - self.amplitude_start)) + ", ")
                else:
                    output.write(str(self.data[i][j] - (self.zero - self.amplitude_start)) + "\n")
        output.close()

    #
    def clearGraph(self):
        self.data = np.zeros(shape=(self.len_ch, self.swipe), dtype=float)
        self.num_sig = 0

    # on change combo box type
    def onChange(self, newIndex):
        if newIndex == 0:
            self.button_file.setEnabled(False)
            self.combobox_serial.setEnabled(True)
        elif newIndex == 1:
            self.button_file.setEnabled(True)
            self.combobox_serial.setEnabled(False)

    # show main window
    def showMainWindow(self):   

        # load data
        self.settings = Settings(window)
        settings_data = self.settings.load()

        # set capture settings
        self.sampleR = int(settings_data['sampleRate'])
        self.len_ch = int(settings_data['channelsPerBoard'])

        # set display settings
        self.swipe = int(settings_data['swipeSamples'])
        self.zero = float(0)
        self.vtick = float(settings_data['vertTick'])
        self.htick = float(settings_data['horizTick'])
        self.amplitude_start = float(settings_data['vMin'])
        self.amplitude_end = float(settings_data['vMax'])
        self.amplitude = self.amplitude_end - self.amplitude_start
        self.amplitude_max = self.amplitude * self.len_ch

        self.start = False
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.mainLoop)

        pg.setConfigOption('background', 'w')
        pg.setConfigOption('foreground', 'k')                
        
        self.pw = pg.GraphicsWindow()
        self.pw.setWindowTitle('EMG')

        # config layout
        self.layout = self.pw.addLayout()

        # config combobox ports
        self.combobox_type = QComboBox()
        self.combobox_type.setEditable(False)
        self.combobox_type.addItem("Serial")      
        self.combobox_type.addItem("File")            
        self.combobox_type.currentIndexChanged.connect(self.onChange)
        proxy_list = QGraphicsProxyWidget()
        proxy_list.setWidget(self.combobox_type)
        self.layout.addItem(proxy_list, row=0, colspan=1)

        # config combobox ports
        self.combobox_serial = QComboBox()
        self.combobox_serial.setEditable(False)
        for port in list_ports.comports():
            self.combobox_serial.addItem(port[0])
        proxy_list = QGraphicsProxyWidget()
        proxy_list.setWidget(self.combobox_serial)
        self.layout.addItem(proxy_list, row=0, colspan=1)

        # config file button
        proxy_file = QGraphicsProxyWidget()
        self.button_file = QPushButton("Select File")
        self.button_file.clicked.connect(self.inputFile)
        proxy_file.setWidget(self.button_file)
        self.button_file.setEnabled(False)
        self.layout.addItem(proxy_file, row=0, colspan=1)

        # config start capture button
        proxy_play = QGraphicsProxyWidget()
        self.button_start = QPushButton('Start Capture')
        self.button_start.clicked.connect(self.startTimer)
        self.button_start.setEnabled(True)
        proxy_play.setWidget(self.button_start)
        self.layout.addItem(proxy_play, row=0, colspan=1)

        # config stop capture button
        proxy_stop = QGraphicsProxyWidget()
        self.button_stop = QPushButton('Stop Capture')
        self.button_stop.clicked.connect(self.stopTimer)
        self.button_stop.setEnabled(False)
        proxy_stop.setWidget(self.button_stop)
        self.layout.addItem(proxy_stop, row=0, colspan=1)

        # config label
        label_configs = pg.LabelItem()
        label_configs.setText("Swipe: " + str(self.swipe) + " | Zero: " + str(self.zero) + " | Amplitude: " +
                              str(self.amplitude) + "V | HTick: " + str(self.htick) + " | VTick " + str(self.vtick) +
                              "V | Channels: " + str(self.len_ch))
        self.layout.addItem(label_configs, row=0, colspan=2)

        #config display settings button
        proxy_settings = QGraphicsProxyWidget()
        button_settings = QPushButton('Display Settings')
        button_settings.clicked.connect(self.showDisplaySettings)
        proxy_settings.setWidget(button_settings)
        self.layout.addItem(proxy_settings, row=0, colspan=1)

        # config capture settings button
        proxy_settings2 = QGraphicsProxyWidget()
        button_settings2 = QPushButton('Capture Settings')
        button_settings2.clicked.connect(self.showCaptureSettings)
        proxy_settings2.setWidget(button_settings2)
        self.layout.addItem(proxy_settings2, row=0, colspan=1)

        # config axis y 
        self.axis_y = DateAxis(orientation='left')
        self.axis_y.setTickSpacing(4000, self.vtick)

        # graph
        self.graph = self.layout.addPlot(axisItems={'left': self.axis_y}, col=0,row=3, colspan=9)
        self.graph.setYRange(0, self.amplitude_max)
        self.graph.showGrid(x=True, y=True, alpha=0.5)
        self.graph.setMenuEnabled(False, 'same')
        self.graph.hideButtons()
        self.graph.setMouseEnabled(False, False)

        # config axis x
        self.axis_x = self.graph.getAxis('bottom')
        self.axis_x.setTickSpacing(self.swipe, self.htick)

        # creating curves
        self.curve = []
        self.data = np.zeros(shape=(self.len_ch, self.swipe), dtype=float)
        for i in range(self.len_ch):
            self.curve.append(self.graph.plot(self.data[i]))
        self.pw.showMaximized()
        self.num_sig = 0

    # start capture
    def startTimer(self):
        if(self.combobox_type.currentText() == "Serial"):
            try:
                if ser.is_open == False:
                    ser.port = self.combobox_serial.currentText()
                    ser.open()

                # log file
                self.log_file = "data/" + datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S') + ".log"
                self.writeHeader()
                ser.write("start\n")
                self.start = True
                self.button_start.setEnabled(False)
                self.button_stop.setEnabled(True)
            except (OSError, serial.SerialException):
                self.showMessage("ERROR", "Serial")
        else:
            try:
                self.f = open(self.file, 'r')
                self.button_start.setEnabled(False)
                self.button_stop.setEnabled(True)
            except:
                self.showMessage("ERROR", "File")

        self.timer.start(0)

    # stop capture
    def stopTimer(self):
        self.timer.stop()
        try:
            if(self.combobox_type.currentText() == "Serial" and self.start == True):
                ser.write("stop\n")
                ser.close()
                self.showMessage("Log", "Stored data.\nfile: "+ self.log_file)
                self.start = False
            else:
                self.f.close()
            self.button_start.setEnabled(True)
            self.button_stop.setEnabled(False)
        except:
            pass

    # plot data emg 
    def mainLoop(self):
        try:
            if(self.combobox_type.currentText() == "Serial"):
                self.captureSerial()
            else:
                self.captureLog()
            self.plot()
        except:
            pass

    # capture serial data
    def captureSerial(self):
        # waiting serial data
        while ser.inWaiting() == 0:
            pass

        # split string and add data
        packet = ser.readline()
        num_ch = 0
        for word in packet[:-1].split():
            self.data[num_ch][self.num_sig] = (int(word) * const_board) + self.zero - self.amplitude_start
            num_ch = (num_ch + 1) % self.len_ch

        self.num_sig += 1

    # capture log data
    def captureLog(self):
        time.sleep(1.0/self.sampleR)
        line = self.f.readline()
        if line == '':
            self.f.seek(0)

        if(line[0] != "#"):
            #add data
            num_ch = 0
            for word in line.rstrip().split(","):
                self.data[num_ch][self.num_sig] = float(word) + self.zero - self.amplitude_start
                num_ch = (num_ch + 1) % self.len_ch
            self.num_sig += 1

    # plot data on graph
    def plot(self):
        # update test graph and store data
        if self.num_sig % self.swipe == 0:
            self.num_sig = 0
            if(self.combobox_type.currentText() == "Serial"):
                self.writeData()

        # plot data in graph
        if self.num_sig % int(self.swipe / 10) == 0:
            for i in range(self.len_ch):
                self.curve[i].setData(self.data[i] + (self.amplitude * i), pen=pg.mkPen('r', width=2))

if __name__ == '__main__':
    app = QtGui.QApplication(sys.argv)
    window = Main()
    window.showMainWindow()
    sys.exit(app.exec_())
    window.stopTimer()